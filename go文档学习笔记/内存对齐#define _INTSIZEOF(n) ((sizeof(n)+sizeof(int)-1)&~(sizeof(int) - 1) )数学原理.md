
参考博客中数学描述比较好，直接复制过来：
https://blog.csdn.net/swell624/article/details/3210779

```
对于两个正整数 x, n 总存在整数 q, r 使得

x = nq + r, 其中  0<= r <n                  //最小非负剩余

q, r 是唯一确定的。q = [x/n], r = x - n[x/n]. 这个是带余除法的一个简单形式。在 c 语言中， q, r 容易计算出来： q = x/n, r = x % n.


所谓把 x 按 n 对齐指的是：若 r=0, 取 qn, 若 r>0, 取 (q+1)n. 这也相当于把 x 表示为：

x = nq + r', 其中 -n < r' <=0                //最大非正剩余   

nq 是我们所求。关键是如何用 c 语言计算它。由于我们能处理标准的带余除法，所以可以把这个式子转换成一个标准的带余除法，然后加以处理：

x+n = qn + (n+r')，其中 0<n+r'<=n            //最大正剩余

x+n-1 = qn + (n+r'-1), 其中 0<= n+r'-1 <n    //最小非负剩余

所以 qn = [(x+n-1)/n]n. 用 c 语言计算就是：

((x+n-1)/n)*n

若 n 是 2 的方幂, 比如 2^m，则除为右移 m 位，乘为左移 m 位。所以把 x+n-1 的最低 m 个二进制位清 0就可以了。得到：

(x+n-1) & (~(n-1))
```
解释一下：
我们知道 2的m次方，比如 2 4 8 16 32 ....减去1  即2^m-1 的二进制全是1  2^m-1 = 111...(二进制有m个1)

若 n 是 2 的方幂, 比如 2^m, ~(n-1) 的二进制是m个0， 那么(x+n-1) & (~(n-1))就是把(x+n-1)的二进制低m位清0

另外一篇文章也解释的蛮好的：
https://www.douban.com/note/707270642/
